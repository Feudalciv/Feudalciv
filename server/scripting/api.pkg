/**********************************************************************
 Freeciv - Copyright (C) 2005 - The Freeciv Project
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
***********************************************************************/

/****************************************************************************
  ADVERTISEMENT: do not attempt to change the name of the API functions.
  They *must* be compatible between the minor Freeciv versions within the
  same major version. If you really like to change a function name, be sure
  to keep also the old one running.
****************************************************************************/

$#ifdef HAVE_CONFIG_H
$#include <config.h>
$#endif

$#include "api_types.h"
$#include "api_actions.h"
$#include "api_effects.h"
$#include "api_find.h"
$#include "api_intl.h"
$#include "api_methods.h"
$#include "api_notify.h"
$#include "api_utilities.h"
$#include "script.h"

/* Classes. */
struct Player_ai {
   bool control;
};

struct Player {
  const char *name;
  Nation_Type *nation;

  Player_ai ai_data;
};

module Player {
  module properties {
    int api_methods_player_number
      @ id (Player *self);
  }

  int api_methods_player_num_cities
    @ num_cities (Player *self);
  int api_methods_player_num_units
    @ num_units (Player *self);
  bool api_methods_player_has_wonder
    @ has_wonder (Player *self, Building_Type *building);
  void api_methods_player_victory
    @ victory (Player *self);
  int api_methods_player_civilization_score
    @ civilization_score (Player *self);
  int api_methods_player_gold
    @ gold (Player *self);
}

module methods_private {
  module Player {
    Unit_List_Link *api_methods_private_player_unit_list_head
      @ unit_list_head (Player *self);
    City_List_Link *api_methods_private_player_city_list_head
      @ city_list_head (Player *self);
  }
}

struct City {
  const char *name;
  Player *owner;
  Player *original;
  Tile *tile;
  int size;

  const int id;
};

module City {
  bool api_methods_city_has_building
    @ has_building(City *self, Building_Type *building);
  int api_methods_city_map_sq_radius
    @ map_sq_radius(City *self);
}


struct Unit {
  Unit_Type *utype;
  Player *owner;

  /* This used to be @ homecity_id, but it does not work with toluaxx. */
  int homecity;
  Tile *tile;

  const int id;
};

module Unit {
  bool api_methods_unit_city_can_be_built_here
    @ is_on_possible_city_tile (Unit *self);
}

struct Tile {
  const int nat_x;
  const int nat_y;

  Terrain *terrain;

  const int index @ id;
};

module Tile {
  City *api_methods_tile_city
    @ city (Tile *self);
  bool api_methods_tile_city_exists_within_max_city_map
    @ city_exists_within_max_city_map (Tile *self, bool center);
  int api_methods_tile_num_units
    @ num_units (Tile *self);
  int api_methods_tile_sq_distance
    @ sq_distance (Tile *self, Tile *other);
}

module methods_private {
  module Tile {
    int api_methods_private_tile_next_outward_index
      @ next_outward_index (Tile *pcenter, int index, int max_dist);
    Tile *api_methods_private_tile_for_outward_index
      @ tile_for_outward_index (Tile *pcenter, int index);
    Unit_List_Link *api_methods_private_tile_unit_list_head
      @ unit_list_head (Tile *self);
  }
}

struct Government {
  const int item_number @ id;
};

module Government {
  const char *api_methods_government_rule_name
    @ rule_name (Government *self);
  const char *api_methods_government_name_translation
    @ name_translation (Government *self);
}

struct Nation_Type {
  const int item_number @ id;
};

module Nation_Type {
  const char *api_methods_nation_type_rule_name
    @ rule_name (Nation_Type *self);
  const char *api_methods_nation_type_name_translation
    @ name_translation (Nation_Type *self);
  const char *api_methods_nation_type_plural_translation
    @ plural_translation (Nation_Type *self);
}

struct Building_Type {
  int build_cost;

  const int item_number @ id;
};

module Building_Type {
  bool api_methods_building_type_is_wonder
    @ is_wonder (Building_Type *self);
  bool api_methods_building_type_is_great_wonder
    @ is_great_wonder (Building_Type *self);
  bool api_methods_building_type_is_small_wonder
    @ is_small_wonder (Building_Type *self);
  bool api_methods_building_type_is_improvement
    @ is_improvement (Building_Type *self);
  const char *api_methods_building_type_rule_name
    @ rule_name (Building_Type *self);
  const char *api_methods_building_type_name_translation
    @ name_translation (Building_Type *self);
}

struct Unit_Type {
  int build_cost;

  const int item_number @ id;
};

module Unit_Type {
  bool api_methods_unit_type_has_flag
    @ has_flag (Unit_Type *self, const char *flag);
  bool api_methods_unit_type_has_role
    @ has_role (Unit_Type *self, const char *role);
  const char *api_methods_unit_type_rule_name
    @ rule_name (Unit_Type *self);
  const char *api_methods_unit_type_name_translation
    @ name_translation (Unit_Type *self);
}

struct Tech_Type {
  const int item_number @ id;
};

module Tech_Type {
  const char *api_methods_tech_type_rule_name
    @ rule_name (Tech_Type *self);
  const char *api_methods_tech_type_name_translation
    @ name_translation (Tech_Type *self);
}

struct Terrain {
  const int item_number @ id;
};

module Terrain {
  const char *api_methods_terrain_rule_name
    @ rule_name (Terrain *self);
  const char *api_methods_terrain_name_translation
    @ name_translation (Terrain *self);
}

struct Unit_List_Link {
};

module Unit_List_Link {
  Unit *api_methods_unit_list_link_data
    @ data (Unit_List_Link *self);
  Unit_List_Link *api_methods_unit_list_next_link
    @ next (Unit_List_Link *self);
}

struct City_List_Link {
};

module City_List_Link {
  City *api_methods_city_list_link_data
    @ data (City_List_Link *self);
  City_List_Link *api_methods_city_list_next_link
    @ next (City_List_Link *self);
}

struct Nonexistent {
};

$[

-- Building_Type methods.
function Building_Type:build_shield_cost()
  return self.build_cost
end

-- Player methods
function Player:is_human()
  return not self.ai_data.control
end

----------------------------------------------------------------------
--  Player and Tile: cities_iterate and units_iterate methods
----------------------------------------------------------------------
do
  local private = methods_private

  -- Iterate over the values of 'array' in order:
  -- array[1], array[2], array[3], etc.
  local function value_iterator(array)
    local i = 0
    local function iterator()
      i = i + 1
      return array[i]
    end
    return iterator
  end

  -- use a copy of the list for safe iteration
  local function safe_iterate_list(link)
    local objs = {}
    while link do
      objs[#objs + 1] = link:data()
      link = link:next()
    end
    return value_iterator(objs)
  end

  -- Safe iteration over all units that belong to Player
  function Player:units_iterate()
    return safe_iterate_list(private.Player.unit_list_head(self))
  end

  -- Safe iteration over all cities that belong to Player
  function Player:cities_iterate()
    return safe_iterate_list(private.Player.city_list_head(self))
  end

  -- Safe iteration over the units on Tile
  function Tile:units_iterate()
    return safe_iterate_list(private.Tile.unit_list_head(self))
  end
end

----------------------------------------------------------------------
--  Tile
--  Deprecated. New one is Tile:city_exists_within_max_city_map().
----------------------------------------------------------------------
function Tile:city_exists_within_city_radius(center)
  return self:city_exists_within_max_city_map(center)
end

----------------------------------------------------------------------
--  Tile: square_iterate, circle_iterate
----------------------------------------------------------------------
do
  local next_outward_index = methods_private.Tile.next_outward_index
  local tile_for_outward_index = methods_private.Tile.tile_for_outward_index

  -- iterate over tiles at distance 'radius'
  function Tile:square_iterate(radius)
    local index = -1
    local function iterator()
      index = next_outward_index(self, index, radius)
      if index < 0 then
        return nil
      else
        return tile_for_outward_index(self, index)
      end
    end
    return iterator
  end

  -- iterate over tiles at squared distance 'sq_radius'
  function Tile:circle_iterate(sq_radius)
    local cr_radius = math.floor(math.sqrt(sq_radius))
    local sq_iter = self:square_iterate(cr_radius)
    local function iterator()
      local tile = nil
      repeat
        tile = sq_iter()
      until not tile or self:sq_distance(tile) <= sq_radius
      return tile
    end
    return iterator
  end
end  -- end do-block (Tile methods)

-- City methods.
function City:exists()
  return true
end

-- Unit methods.
function Unit:exists()
  return true
end

function Unit:get_homecity()
  return find.city(self.owner, self.homecity)
end

-- Unit_Type methods.
function Unit_Type:build_shield_cost()
  return self.build_cost
end

-- Nonexistent methods.
function Nonexistent:exists()
  return false
end

-- Hide all private methods
methods_private = nil
$]

$[
----------------------------------------------------------------------
--  API Types Special Methods
----------------------------------------------------------------------
do
  local api_types = {
    "Player",
    "Unit",
    "City",
    "Tile",
    "Government",
    "Nation_Type",
    "Building_Type",
    "Unit_Type",
    "Tech_Type",
    "Terrain",
    "Nonexistent",
  }

  local function id_eq (o1, o2)
    return o1.id == o2.id and (o1.id ~= nil)
  end

  -- define string representation when printed
  local function string_rep(self)
    local id = self.id
    local name = self.rule_name and self:rule_name() or self.name
    if name and id then
      return string.format('<%s #%d %s>', tolua.type(self), id, name)
    elseif id then
      return string.format('<%s #%d>', tolua.type(self), id)
    else
      return string.format('<%s>', tolua.type(self))
    end
  end

  for index, typename in ipairs(api_types) do
    local api_type = _G[typename]

    api_type[".eq"] = id_eq
    api_type.__tostring = string_rep

    -- Properties are fields that call an accessor to get their value
    -- A property named 'id' defined by 'function' is accessed like:
    --  local id = player.id
    -- but what happens is:
    --  local id = function(player)
    if api_type.properties then
      local api_type_index = api_type.__index
      local properties = api_type.properties
      local function property_getter(self, field)
        local getter = properties[field]
        if getter then
          return getter(self)
        else
          return api_type_index(self, field)
        end
      end
      api_type.__index = property_getter
    end
  end
-- End (API Types Special Methods)
end

$]

/* Object find module. */
module find {
  Player *api_find_player @ player (int player_id);
  City *api_find_city @ city (Player *pplayer, int city_id);
  Unit *api_find_unit @ unit (Player *pplayer, int unit_id);
  Tile *api_find_tile @ tile (int nat_x, int nat_y);
  Tile *api_find_tile_by_index @ tile (int index);

  /* NOTE: For overloading to work correctly, the string function
     must be before the integer function for each case below
   */
  Government *api_find_government_by_name
    @ government (const char *name_orig);
  Government *api_find_government
    @ government (int government_id);
  Nation_Type *api_find_nation_type_by_name
    @ nation_type (const char *name_orig);
  Nation_Type *api_find_nation_type
    @ nation_type (int nation_type_id);
  Building_Type *api_find_building_type_by_name
    @ building_type (const char *name_orig);
  Building_Type *api_find_building_type
    @ building_type (int building_type_id);
  Unit_Type *api_find_unit_type_by_name
    @ unit_type (const char *name_orig);
  Unit_Type *api_find_unit_type
    @ unit_type (int unit_type_id);
  Unit_Type *api_find_role_unit_type
    @ role_unit_type (const char *role_name, Player *pplayer);
  Tech_Type *api_find_tech_type_by_name
    @ tech_type (const char *name_orig);
  Tech_Type *api_find_tech_type
    @ tech_type (int tech_type_id);
  Terrain *api_find_terrain_by_name
    @ terrain (const char *name_orig);
  Terrain *api_find_terrain
    @ terrain (int terrain_id);
  Nonexistent *api_find_nonexistent
    @ nonexistent ();
}

$[
-- Dump the state of user scalar variables to a Lua code string.
function _freeciv_state_dump()
  local res = ''

  for k, v in pairs(_G) do
    if k == '_VERSION' then
      -- ignore _VERSION variable.
    elseif type(v) == 'boolean'
        or type(v) == 'number' then
      local rvalue = tostring(v)

      res = res .. k .. '=' .. rvalue .. '\n'
    elseif type(v) == 'string' then
      local rvalue = string.format('%q', v)

      res = res .. k .. '=' .. rvalue .. '\n'
    elseif type(v) == 'userdata' then
      local method = string.lower(tolua.type(v))

      res = res .. k .. '=find.' .. method
      if method == 'city' or method == 'unit' then
        res = res .. '(nil,' .. v.id .. ')'
      elseif v.id then
        res = res .. '(' .. v.id .. ')'
      else
        res = res .. '()'
      end
      res = res .. '\n'
    end
  end

  return res
end
$]

$[
----------------------------------------------------------------------
-- Iteration constructs for game-global objects
----------------------------------------------------------------------
do
  -- iterate over the values returned by lookup
  -- until nil is returned:
  -- lookup(0), lookup(1), lookup(2), etc
  local function index_iterate(lookup)
    local index = -1
    local function iterator()
      index = index + 1
      return lookup(index)
    end
    return iterator
  end

  -- Iterate over all players of the game
  function players_iterate()
    return index_iterate(find.player)
  end

  -- Iterate over all tiles of the game
  function whole_map_iterate()
    return index_iterate(find.tile)
  end

  -- NOTE: Identical further definitions can be made for
  -- governments, tech_types, building_types etc
end

$]

/* Signal module. */
module signal {
  void script_signal_connect @ connect(const char *signal_name,
                                       const char *callback_name);
}

/* Intl module. */
const char *api_intl__ @ _ (const char *untranslated);
const char *api_intl_N_ @ N_ (const char *untranslated);
const char *api_intl_Q_ @ Q_ (const char *untranslated);
const char *api_intl_PL_ @ PL_ (const char *singular, const char *plural,
                                int n);

/* Notify module. */
module notify {
  void api_notify_embassies_msg @ embassies_msg (Player *pplayer,
                                                 Tile *ptile,
                                                 int event,
                                                 const char *message);
  void api_notify_event_msg @ event_msg (Player *pplayer, Tile *ptile,
                                         int event, const char *message);
}

/* Notify events module. */
module E {
  enum event_type {
    E_CITY_CANTBUILD @ CITY_CANTBUILD,
    E_CITY_LOST @ CITY_LOST,
    E_CITY_LOVE @ CITY_LOVE,
    E_CITY_DISORDER @ CITY_DISORDER,
    E_CITY_FAMINE @ CITY_FAMINE,
    E_CITY_FAMINE_FEARED @ CITY_FAMINE_FEARED,
    E_CITY_GROWTH @ CITY_GROWTH,
    E_CITY_MAY_SOON_GROW @ CITY_MAY_SOON_GROW,
    E_CITY_AQUEDUCT @ CITY_AQUEDUCT,
    E_CITY_AQ_BUILDING @ CITY_AQ_BUILDING,
    E_CITY_NORMAL @ CITY_NORMAL,
    E_CITY_NUKED @ CITY_NUKED,
    E_CITY_CMA_RELEASE @ CITY_CMA_RELEASE,
    E_CITY_GRAN_THROTTLE @ CITY_GRAN_THROTTLE,
    E_CITY_TRANSFER @ CITY_TRANSFER,
    E_CITY_BUILD @ CITY_BUILD,
    E_CITY_PRODUCTION_CHANGED @ CITY_PRODUCTION_CHANGED,
    E_CITY_PLAGUE @ CITY_PLAGUE,
    E_CITY_RADIUS_SQ @ CITY_RADIUS_SQ,
    E_WORKLIST @ WORKLIST,
    E_UPRISING @ UPRISING,
    E_CIVIL_WAR @ CIVIL_WAR,
    E_ANARCHY @ ANARCHY,
    E_FIRST_CONTACT @ FIRST_CONTACT,
    E_NEW_GOVERNMENT @ NEW_GOVERNMENT,
    E_LOW_ON_FUNDS @ LOW_ON_FUNDS,
    E_POLLUTION @ POLLUTION,
    E_REVOLT_DONE @ REVOLT_DONE,
    E_REVOLT_START @ REVOLT_START,
    E_SPACESHIP @ SPACESHIP,
    E_MY_DIPLOMAT_BRIBE @ MY_DIPLOMAT_BRIBE,
    E_DIPLOMATIC_INCIDENT @ DIPLOMATIC_INCIDENT,
    E_MY_DIPLOMAT_ESCAPE @ MY_DIPLOMAT_ESCAPE,
    E_MY_DIPLOMAT_EMBASSY @ MY_DIPLOMAT_EMBASSY,
    E_MY_DIPLOMAT_FAILED @ MY_DIPLOMAT_FAILED,
    E_MY_DIPLOMAT_INCITE @ MY_DIPLOMAT_INCITE,
    E_MY_DIPLOMAT_POISON @ MY_DIPLOMAT_POISON,
    E_MY_DIPLOMAT_SABOTAGE @ MY_DIPLOMAT_SABOTAGE,
    E_MY_DIPLOMAT_THEFT @ MY_DIPLOMAT_THEFT,
    E_ENEMY_DIPLOMAT_BRIBE @ ENEMY_DIPLOMAT_BRIBE,
    E_ENEMY_DIPLOMAT_EMBASSY @ ENEMY_DIPLOMAT_EMBASSY,
    E_ENEMY_DIPLOMAT_FAILED @ ENEMY_DIPLOMAT_FAILED,
    E_ENEMY_DIPLOMAT_INCITE @ ENEMY_DIPLOMAT_INCITE,
    E_ENEMY_DIPLOMAT_POISON @ ENEMY_DIPLOMAT_POISON,
    E_ENEMY_DIPLOMAT_SABOTAGE @ ENEMY_DIPLOMAT_SABOTAGE,
    E_ENEMY_DIPLOMAT_THEFT @ ENEMY_DIPLOMAT_THEFT,
    E_CARAVAN_ACTION @ CARAVAN_ACTION,
    E_SCRIPT @ SCRIPT,
    E_BROADCAST_REPORT @ BROADCAST_REPORT,
    E_GAME_END @ GAME_END,
    E_GAME_START @ GAME_START,
    E_LOG_ERROR @ E_LOG_ERROR,
    E_MESSAGE_WALL @ MESSAGE_WALL,
    E_NATION_SELECTED @ NATION_SELECTED,
    E_DESTROYED @ DESTROYED,
    E_REPORT @ REPORT,
    E_TURN_BELL @ TURN_BELL,
    E_NEXT_YEAR @ NEXT_YEAR,
    E_GLOBAL_ECO @ GLOBAL_ECO,
    E_NUKE @ NUKE,
    E_HUT_BARB @ HUT_BARB,
    E_HUT_CITY @ HUT_CITY,
    E_HUT_GOLD @ HUT_GOLD,
    E_HUT_BARB_KILLED @ HUT_BARB_KILLED,
    E_HUT_MERC @ HUT_MERC,
    E_HUT_SETTLER @ HUT_SETTLER,
    E_HUT_TECH @ HUT_TECH,
    E_HUT_BARB_CITY_NEAR @ HUT_BARB_CITY_NEAR,
    E_IMP_BUY @ IMP_BUY,
    E_IMP_BUILD @ IMP_BUILD,
    E_IMP_AUCTIONED @ IMP_AUCTIONED,
    E_IMP_AUTO @ IMP_AUTO,
    E_IMP_SOLD @ IMP_SOLD,
    E_TECH_GAIN @ TECH_GAIN,
    E_TECH_LEARNED @ TECH_LEARNED,
    E_TREATY_ALLIANCE @ TREATY_ALLIANCE,
    E_TREATY_BROKEN @ TREATY_BROKEN,
    E_TREATY_CEASEFIRE @ TREATY_CEASEFIRE,
    E_TREATY_PEACE @ TREATY_PEACE,
    E_TREATY_SHARED_VISION @ TREATY_SHARED_VISION,
    E_UNIT_LOST_ATT @ UNIT_LOST_ATT,
    E_UNIT_WIN_ATT @ UNIT_WIN_ATT,
    E_UNIT_BUY @ UNIT_BUY,
    E_UNIT_BUILT @ UNIT_BUILT,
    E_UNIT_LOST_DEF @ UNIT_LOST_DEF,
    E_UNIT_WIN @ UNIT_WIN,
    E_UNIT_LOST_MISC @ UNIT_LOST_MISC,
    E_UNIT_BECAME_VET @ UNIT_BECAME_VET,
    E_UNIT_UPGRADED @ UNIT_UPGRADED,
    E_UNIT_RELOCATED @ UNIT_RELOCATED,
    E_UNIT_ORDERS @ UNIT_ORDERS,
    E_VOTE_NEW @ VOTE_NEW,
    E_VOTE_RESOLVED @ VOTE_RESOLVED,
    E_VOTE_ABORTED @ VOTE_ABORTED,
    E_WONDER_BUILD @ WONDER_BUILD,
    E_WONDER_OBSOLETE @ WONDER_OBSOLETE,
    E_WONDER_STARTED @ WONDER_STARTED,
    E_WONDER_STOPPED @ WONDER_STOPPED,
    E_WONDER_WILL_BE_BUILT @ WONDER_WILL_BE_BUILT,
    E_DIPLOMACY @ DIPLOMACY,
    E_TREATY_EMBASSY @ TREATY_EMBASSY,
    E_BAD_COMMAND @ BAD_COMMAND,
    E_SETTING @ SETTING,
    E_CHAT_MSG @ CHAT_MSG,
    E_CHAT_ERROR @ CHAT_ERROR,
    E_CONNECTION @ CONNECTION,
    E_AI_DEBUG @ AI_DEBUG,
    E_LOG_FATAL @ LOG_FATAL,
    E_TECH_GOAL @ TECH_GOAL,

    E_LAST @ LAST
  };
}

$[
-- Notify module implementation.

function notify.all(...)
  notify.event_msg(nil, nil, E.SCRIPT, string.format(unpack(arg)))
end

function notify.player(player, ...)
  notify.event_msg(player, nil, E.SCRIPT, string.format(unpack(arg)))
end

function notify.event(player, tile, event, ...)
  notify.event_msg(player, tile, event, string.format(unpack(arg)))
end

function notify.embassies(player, ptile, event, ...)
  notify.embassies_msg(player, ptile, event, string.format(unpack(arg)))
end
$]

/* Effects module */
module effects {
  int api_effects_world_bonus @ world_bonus (const char *effect_type);
  int api_effects_player_bonus @ player_bonus (Player *pplayer,
                                               const char *effect_type);
  int api_effects_city_bonus @ city_bonus (City *pcity,
                                           const char *effect_type);
}

/* Utilities module. */
int api_utilities_random @ random (int min, int max);
void api_utilities_error_log @ error_log (const char *msg);
void api_utilities_debug_log @ debug_log (const char *msg);


/* Actions module. */
Unit *api_actions_create_unit @ create_unit (Player *pplayer, Tile *ptile,
                                             Unit_Type *ptype,
                                             int veteran_level,
                                             City *homecity, int moves_left);
void api_actions_create_city @ create_city (Player *pplayer, Tile *ptile,
                                            const char *name);
void api_actions_create_base @ create_base (Tile *ptile, const char *name,
                                            Player *pplayer);
void api_actions_change_gold @ change_gold (Player *pplayer, int amount);
Tech_Type *api_actions_give_technology @ give_technology (Player *pplayer,
                                                          Tech_Type *ptech,
                                                          const char *reason);
bool api_actions_unleash_barbarians @ unleash_barbarians (Tile *ptile);
void api_actions_place_partisans @ place_partisans (Tile *ptile,
                                                    Player *pplayer,
                                                    int count,
                                                    int sq_radius);
